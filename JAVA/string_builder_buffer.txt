String Class에서 자주 사용되는 메소드 설명

1. charAt() -> 문자열의 특정 인덱스에 해당하는 문자 반환
			인덱스 체계 적용돼서 0이 아닌 1부터 시작

2. compareTo() -> 전달받은 문자열을 사전순으로 비교, 대소문자 영향 有
			비교하는 문자열들끼리 같으면 0
			양수면 기준 문자열이 사전적으로 뒤
			음수면 기준 문자열이 사전적으로 앞

3. concat() -> mariaDB에서 사용했던 것처럼 기존 문자열 + 전달 받은 문자열 합치기
			기존 문자열에 영향 X

4. indexOf() -> 문자열에서 특정 문자 탐색 후 처음으로 일치하는 인덱스 위치 정수로 출력
			일치하는 문자가 없을 경우 -1 반환

5. lastIndexOf() -> indexOf과 기능은 동일하지만 뒤에서부터 탐색 
			역시 일치하는 문자 없을 경우 -1 반환

6. trim() -> mariaDB와 동일, 문자열의 앞뒤 공백 전부 제거 후 반환
			기존 문자열에 영향 X

7. toLowerCase(), toUpperCase() -> 각각 전부 소문자, 대문자로 변환

8. subString() -> 인덱스 기준으로 문자열 잘라내서 반환
			(n, m) -> n번 인덱스부터 m번 인덱스까지 잘라서 반환
			(n) -> n번 인덱스부터 끝까지 잘라서 반환

9. replace() -> 타겟 문자열과 대체할 문자열 입력해서 변경 후 반환
			기존 문자열에 영향 X

10. length() -> 문자열의 길이를 정수형으로 변환
			배열에서는 length 뒤에 () 사용 X, String 클래서에서만 괄호 사용

11. isEmpty() -> 문자열이 비어있는지 알려주는 메소드 
			비어있으면 true, 비어있지 않으면 false 반환

문자열 객체 생성 방법

1. 리터럴 형태로 생성시 동일한 값을 가지는 인스턴스를 단일 인스턴스로 관리
2. new String 형태로 생성 시 생성할 때마다 새로운 인스턴스를 생성하기 때문에 주소값이 다름
	String 객체가 heap 메모리 영역에 생성 되는데, 이 메모리에 할당된 위치가 다르다는 뜻

String 객체의 동등성 비교

1. == 연산자는 주소값 비교 -> 리터럴 형태로 생성된 경우, 상수풀에 저장되기 때문에 
	같은 문자열 리터럴은 같은 주소값을 사용하기 때문에 true 반환
	상수풀 -> 동등한 String 객체일 때, 중복되는 경우 제거해 하나만 저장
2. equals() -> 문자열의 내용만 비교하기 때문에 생김새만 같은 문자열이면 true 반환

String 클래스에서 hashCode()는 문자열 내용을 기반으로 계산되기 때문에 같은 내용을 가지는
str1과 str3의 hashCode() 동일하다고 나옴

문자열 분리

1. 문자열을 특정 구분자를 기준으로 분리해 배열로 반환하는 기능
split() -> 정규표현식 이용해 정형화된 문자열을 분리

2.StringTokenizer -> 배열로 반환X
구분자를 통해 토큰 단위로 구분하고 각각의 토큰에 접근할 수 있게 함
while문 통해 남은 토큰이 없을 때까지 각 토큰 출력

escape문

문자열 내에서 사용하는 특수기능 위한 문자
역슬래쉬 사용 -> 엔터처리, 탭, 작은 따옴표, 큰 따옴표, 역슬래쉬 인식

StringBuilder -> StringBuffer보다 속도 빠름, 리터럴 취급
StringBuffer -> 스레드 세이프 추가로 가능 (멀티 스레드 적합)

String -> hashCode() 메소드가 주소값이 아니라 내용을 기준으로 동등성 비교하게 오버라이딩
객체의 실제 주소값이 달라도 같은 내용이면 동등하다고 간주
따라서 System.identityHashCode() 통해 hashCode 값 비교

뒤에 0123456 순으로 숫자 추가하며 내용 변경 통해 해시값 변경 유무 확인

String은 내용이 기준이고 생성 이후 변경할 수 없기 때문에 
내용이 변하면 새 객체 취급해서 hashCode가 달라짐
출력 결과를 보면 hashCode전부 다름 

capacity() -> 객체의 현재 용량 반환
문자열이 길어져 용량이 부족할 것 같으면 기존 용량*2+2 

StringBuilder hashCode -> 계속 동일한 것으로 보아 새 객체 생성X,
아예 새롭게 객체를 생성하지 않는 이상 
가변 문자열인 StringBuilder는 내용이 바뀌어도 hashCode 변화 X

StringBuilder의 delete(), deleteChartAt() -> 기존 문자열 영향 O
delete() -> 시작 인덱스와 종료 인덱스 설정해 원하는 구간 삭제
deleteCharAt() -> 문자열 인덱스 하나 입려해 특정 문자 제거

insert() ->기존 문자열 영향 O
입력한 인덱스 위치에 지정한 문자열 추가
length() 이요하면 기존 문자열 맨 뒤에 지정 문자열 추가

reverse() -> 기존 문자열 영향 O
인덱스 순서 역순 재배열 해서 기존 문자열 뒤집힘

String -> 변할 일 없는 문자열, 안전하게 공유
StringBulder -> 가변성 필요한 문자열, 단일 스레드, 문자열 조작 많은 경우
StringBuffer -> 가변성 필요한 문자열, 멀티 스레드, 스레드 동기화

















